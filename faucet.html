<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHRS æ°´é¾™å¤´ - Goosebox</title>
    
    <link rel="icon" type="image/x-icon" href="assets/logo_beta.png">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://www.google.com/recaptcha/api.js" async defer></script>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/lipis/flag-icons@7.3.2/css/flag-icons.min.css" />
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        wood:  { 50:'#f6efe9',100:'#eadfd3',200:'#d8c1a8',300:'#c8a37e',400:'#b8875a',500:'#9b6f48',600:'#7c583a',700:'#654830',800:'#523a26',900:'#3e2c1d'},
                        hay:   { 50:'#fff8e6',100:'#ffefc2',200:'#ffe38f',300:'#ffd24d',400:'#fbbf24',500:'#f59e0b'},
                        field: { 50:'#f4fde8',100:'#e3fac5',200:'#c6f18c',300:'#a2e251',400:'#7ace24',500:'#5cab17'},
                        stone: { 300:'#d1d5db',400:'#9ca3af',700:'#374151'}
                    },
                    boxShadow: { ui:'0 8px 20px rgba(0,0,0,.12)' },
                    borderRadius: { ui:'18px' }
                }
            }
        }
    </script>
    
    <style>
        .grain {
            background:
                radial-gradient(1000px 400px at 80% -20%, rgba(255,255,255,.25), rgba(255,255,255,0)),
                linear-gradient(180deg, #f7e7d5 0%, #fff6e8 40%, #f9efe3 100%);
        }
        .float { animation: float 4s ease-in-out infinite; }
        @keyframes float { 0%{transform:translateY(0)}50%{transform:translateY(-8px)}100%{transform:translateY(0)} }
        .logo { height: 50px; width: auto; }
    </style>
</head>
<body class="bg-wood-50 text-stone-700">

    <header class="sticky top-0 z-50">
        <div class="bg-wood-400 shadow-ui text-white">
            <div class="max-w-6xl mx-auto px-4 py-3 flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <img alt="Goosebox Logo" class="logo" loading="lazy" src="assets/logo_beta.png"/>
                    <div class="leading-tight">
                        <div class="font-extrabold text-lg">Goosebox</div>
                        <div class="text-white/80 text-xs" id="subtitle" data-lang="faucet.subtitle">PHRS æ°´é¾™å¤´</div>
                    </div>
                </div>

                <nav class="hidden md:flex items-center gap-6 text-white/90">
                    <a href="index.html#home" class="hover:text-white" data-lang="nav.home"></a>
                    <a href="index.html#mechanics" class="hover:text-white" data-lang="nav.highlights"></a>
                    <a href="index.html#play" class="hover:text-white" data-lang="nav.play"></a>
                    <a href="index.html#faq" class="hover:text-white" data-lang="nav.faq"></a>
                    
                    <!-- è¯­è¨€é€‰æ‹©å™¨ -->
                    <div class="relative group">
                        <button class="flex items-center gap-2 hover:text-white transition-colors duration-200" id="currentLang">
                            <span id="currentLangFlag" class="fi fi-cn text-lg"></span>
                            <span id="currentLangName">ä¸­æ–‡</span>
                        </button>
                        <div class="absolute left-1/2 -translate-x-1/2 top-full mt-2 bg-white rounded-ui shadow-ui border border-wood-200 py-2 min-w-[180px] opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 transform origin-top scale-95 group-hover:scale-100">
                            <div id="languageOptions"></div>
                        </div>
                    </div>
                    
                    <button id="open-connect-modal" class="px-4 py-2 rounded-ui bg-hay-400 text-wood-900 font-bold hover:bg-hay-300 transition-colors duration-200" data-lang="nav.wallet">
                    </button>
                </nav>
                
                <div class="md:hidden flex items-center gap-2">
                    <button id="open-connect-modal-mobile" class="px-3 py-2 rounded-ui bg-hay-400 text-wood-900 font-bold text-sm hover:bg-hay-300 transition-colors duration-200" data-lang="nav.wallet">
                    </button>
                </div>
            </div>
        </div>
    </header>

    <section class="grain">
        <div class="max-w-6xl mx-auto px-4 py-12 md:py-16">
            <div class="grid md:grid-cols-2 gap-8 items-center">
                <div>
                    <h1 class="text-3xl md:text-4xl font-extrabold text-wood-900 leading-tight" id="heroTitle" data-lang="faucet.heroTitle">PHRS æ°´é¾™å¤´</h1>
                    <p class="mt-4 text-stone-700" id="heroDescription" data-lang="faucet.heroDescription">æ¯æ—¥å…è´¹é¢†å– 0.1 PHRS æµ‹è¯•ä»£å¸ï¼Œä½“éªŒ Goosebox ç”Ÿæ€ç³»ç»Ÿ</p>
                    <div class="mt-6 p-4 bg-white/80 rounded-ui border border-wood-200">
                        <div class="text-sm text-stone-600 mb-2" data-lang="faucet.networkInfo.title">ç½‘ç»œä¿¡æ¯</div>
                        <div class="text-stone-700">
                            <div data-lang="faucet.networkInfo.network"><strong>ç½‘ç»œ:</strong> Pharos Testnet (Chain ID: 688688)</div>
                            <div data-lang="faucet.networkInfo.dailyLimit"><strong>æ¯æ—¥é™é¢:</strong> 0.1 PHRS</div>
                            <div data-lang="faucet.networkInfo.cooldown"><strong>å†·å´æœŸ:</strong> 24å°æ—¶</div>
                        </div>
                    </div>
                </div>

                <div class="float">
                    <img src="assets/goosebox_ranch.png" alt="Goosebox Ranch" class="w-full" loading="lazy">
                </div>
            </div>
        </div>
    </section>

    <section class="py-12">
        <div class="max-w-4xl mx-auto px-4">
            
            <div class="rounded-ui bg-white border border-wood-200 p-6 shadow-ui mb-6">
                <h3 class="text-xl font-bold text-wood-900 mb-4" data-lang="faucet.sections.walletConnection">1. é’±åŒ…è¿æ¥çŠ¶æ€</h3>
                <div id="walletStatus" class="text-stone-600" data-lang="faucet.walletStatus.integrated">é’±åŒ…å·²é›†æˆï¼Œè¿æ¥åå°†è‡ªåŠ¨å¼€å§‹è®¤è¯æµç¨‹</div>
            </div>

            <!-- Twitter çŠ¶æ€æ˜¾ç¤ºï¼ˆç‹¬ç«‹äº Twitter OAuth éƒ¨åˆ†ï¼‰ -->
            <div id="twitterStatusSection" class="rounded-ui bg-white border border-wood-200 p-6 shadow-ui mb-6" style="display: none;">
                <h3 class="text-xl font-bold text-wood-900 mb-4" data-lang="faucet.sections.twitterStatus">2. X è´¦æˆ·çŠ¶æ€</h3>
                <div id="twitterStatus" class="text-stone-600 mb-4"></div>
                <div class="flex gap-4 mb-4">
                    <button id="disconnectTwitter" style="display: none;" class="px-6 py-3 rounded-ui bg-red-400 text-white font-medium hover:bg-red-300 transition-colors duration-200" data-lang="faucet.twitter.disconnectButton">
                        æ–­å¼€ Twitter
                    </button>
                </div>
            </div>

            <div id="twitterOAuthSection" class="rounded-ui bg-white border border-wood-200 p-6 shadow-ui mb-6">
                <h3 class="text-xl font-bold text-wood-900 mb-4" data-lang="faucet.sections.twitterIntegration">2. Link X account</h3>    
                <!-- Twitter å›è°ƒçŠ¶æ€æç¤º -->
                <!-- <div id="twitterCallbackStatus" class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg" style="display: none;">
                    <div class="text-sm text-blue-800">
                        <strong>ğŸ”— Twitter æˆæƒå›è°ƒæ£€æµ‹åˆ°</strong><br>
                        <span id="twitterCallbackDetails">æ­£åœ¨å¤„ç†æˆæƒ...</span>
                    </div>
                </div> -->
                <div id="twitterOAuthStatus" class="text-stone-600 mb-4"></div>
                <div class="flex gap-2">
                    <button id="connectTwitter" disabled class="px-6 py-3 rounded-ui bg-blue-400 text-white font-medium hover:bg-blue-300 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed" data-lang="faucet.twitter.connectButton">
                        è¿æ¥ Twitter
                    </button>
                </div>
            </div>



            <div id="faucetClaimSection" class="rounded-ui bg-white border border-wood-200 p-6 shadow-ui mb-6">
                <h3 class="text-xl font-bold text-wood-900 mb-4" data-lang="faucet.sections.claimTokens">3. é¢†å– PHRS ä»£å¸</h3>
                
                <div class="mb-4 p-4 bg-field-50 border border-field-200 rounded-lg">
                    <div class="text-sm text-stone-600 mb-2" data-lang="faucet.claim.instructions">é¢†å–è¯´æ˜</div>
                    <ul class="text-sm text-stone-700 space-y-1">
                        <li data-lang="faucet.claim.instruction1">â€¢ æ¯ä¸ªé’±åŒ…åœ°å€æ¯24å°æ—¶åªèƒ½é¢†å–ä¸€æ¬¡</li>
                        <li data-lang="faucet.claim.instruction2">â€¢ æ¯æ¬¡é¢†å– 0.1 PHRS æµ‹è¯•ä»£å¸</li>
                        <li data-lang="faucet.claim.instruction3">â€¢ éœ€è¦å®Œæˆç­¾åç™»å½•å’Œ reCAPTCHA éªŒè¯</li>
                        <li data-lang="faucet.claim.instruction4">â€¢ å»ºè®®ç»‘å®š Twitter è´¦æˆ·ä»¥è·å¾—æ›´å¥½çš„æœåŠ¡</li>
                        <li data-lang="faucet.claim.instruction5">â€¢ ä½¿ç”¨é’±åŒ…è¿æ¥</li>
                        <li data-lang="faucet.claim.instruction6">â€¢ ç¡®ä¿åœ¨ Pharos Testnet ç½‘ç»œä¸Š</li>
                    </ul>
                </div>

                <div id="faucet-recaptcha-container" class="mb-4">
                    <div class="g-recaptcha" data-sitekey="6LchwbIrAAAAAEkI8iLHCgWV13kSiQhj9Wov_1he" data-callback="onFaucetRecaptchaSuccess" data-expired-callback="onFaucetRecaptchaExpired"></div>
                </div>

                <div class="text-sm text-stone-500 mb-2" data-lang="faucet.claim.autoCheckAfterLogin">ç™»å½•æˆåŠŸåè‡ªåŠ¨æ£€æŸ¥çŠ¶æ€</div>
                <div class="flex gap-2 mb-4">
                    <button id="checkFaucetStatus" disabled class="px-4 py-2 rounded-ui bg-wood-300 text-wood-900 font-medium hover:bg-wood-200 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed" data-lang="faucet.claim.manualCheckButton">
                        æ‰‹åŠ¨æ£€æŸ¥çŠ¶æ€
                    </button>
                <button id="claimTokens" disabled class="px-6 py-3 rounded-ui bg-hay-400 text-wood-900 font-bold shadow-ui hover:bg-hay-300 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200">
                    <span id="claimButtonText" data-lang="faucet.claim.claimButton">é¢†å–ä»£å¸</span>
                    <span id="claimCountdown" class="hidden"></span>
                </button>
                </div>

                <div id="faucetStatus" class="mt-4"></div>
            </div>



        </div>
    </section>

    <footer class="bg-white border-t border-wood-200 mt-12">
        <div class="max-w-6xl mx-auto px-4 py-8 flex flex-col items-center gap-4">
            <div class="flex items-center gap-4">
                <a href="https://x.com/GooseBoxGame" target="_blank" rel="noopener noreferrer"
                   class="inline-flex items-center gap-2 px-4 py-2 rounded-[14px] bg-wood-100 border border-wood-200 text-wood-900 shadow-ui hover:bg-wood-200">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1200 1227" class="w-5 h-5" fill="currentColor">
                        <path d="M714 519l452-519H1002L652 408 357 0H0l469 638L0 1227h198l375-431 311 431h357L714 519zM593 742l-86-118-308 353h180l214-235zm263 170L742 694l-84 92 220 305h170L856 912zM326 142l610 910h-171L261 142h65z"/>
                    </svg>
                    <span>X</span>
                </a>
                <a href="https://t.me/GooseBoxTG" target="_blank" rel="noopener noreferrer"
                   class="inline-flex items-center gap-2 px-4 py-2 rounded-[14px] bg-wood-100 border border-wood-200 text-wood-900 shadow-ui hover:bg-wood-200">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" class="w-5 h-5" fill="currentColor">
                        <path d="M120 0a120 120 0 10120 120A120 120 0 00120 0zm58.1 75.5L147 179.8c-2 9.2-7.5 11.4-15.2 7.1l-42-31  -20.2 19.4c-2.2 2.2-4 4-8.2 4l2.9-41.2 74.9-67.5c3.3-2.9-.7-4.6-5.1-1.7l-92.5 58.2-39.8-12.4c-8.6-2.7-8.8-8.6 1.8-12.7l155.8-60.1c7.2-2.6 13.5 1.7 11.1 12.1z"/>
                    </svg>
                    <span>Telegram</span>
                </a>
            </div>
            <p class="text-stone-400">Â© 2025 Goosebox</p>
        </div>
    </footer>

    <script src="public/js/languages.js"></script>
    
    <script type="module" src="/src/main.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"
            onerror="loadBackupEthers()"></script>
    <script>
        function loadBackupEthers() {
            console.log('ä¸» CDN å¤±è´¥ï¼Œå°è¯•å¤‡ç”¨ CDN...');
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js';
            script.onerror = function() {
                console.error('æ‰€æœ‰ ethers.js CDN éƒ½å¤±è´¥äº†');
                alert('ethers.js åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢é‡è¯•');
            };
            document.head.appendChild(script);
        }
    </script>
    
    <script>
        // å…¨å±€çŠ¶æ€
        let walletAddress = null;
        let currentNonce = null;
        let currentMessage = null;
        let authToken = null;
        let faucetRecaptchaToken = null;
        let countdownTimer = null;
        let currentCooldownTime = 0;

        // çŠ¶æ€æ¶ˆæ¯è¿½è¸ªç³»ç»Ÿ
        const currentStatusStates = {
            walletStatus: { type: null, messageKey: null, params: null, isCustom: false },
            twitterStatus: { type: null, messageKey: null, params: null, isCustom: false },
            faucetStatus: { type: null, messageKey: null, params: null, isCustom: false }
        };

        const API_BASE = 'https://api.gbox.game/api/faucet-auth';

        const NETWORK_CONFIG = {
            chainId: 688688,
            chainIdHex: '0xA8230',
            networkName: 'Pharos Testnet',
            rpcUrl: 'https://testnet.dplabs-internal.com',
            blockExplorerUrl: 'https://testnet.pharosscan.xyz',
            currencySymbol: 'PHRS',
            currencyDecimals: 18
        };

        const FAUCET_CONTRACT_ADDRESS = '0x14395C2E7beB6D32020E84f8849C06564c92ad40';
        const CHAIN_ID = NETWORK_CONFIG.chainId;

        const FAUCET_ABI = [
            {
                "inputs": [
                    {"internalType": "uint256", "name": "amount", "type": "uint256"},
                    {"internalType": "bytes32", "name": "nonce", "type": "bytes32"},
                    {"internalType": "uint256", "name": "timestamp", "type": "uint256"},
                    {"internalType": "string", "name": "ip", "type": "string"},
                    {"internalType": "string", "name": "twitterId", "type": "string"},
                    {"internalType": "bytes", "name": "signature", "type": "bytes"}
                ],
                "name": "claimTokens",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        let currentLang = 'zh';

        function initLanguage() {
            const savedLang = localStorage.getItem('goosebox_lang');
            const config = getLanguageConfig();
            if (savedLang && config[savedLang]) {
                currentLang = savedLang;
            }
            updateLanguage(currentLang);
            renderLanguageSelector();
        }

        function updateLanguage(lang) {
            const langData = getLanguageData(lang);
            
            // æ›´æ–°é¡µé¢æ ‡é¢˜
            document.title = langData.faucet?.title ? `${langData.faucet.title} - Goosebox` : (lang === 'zh' ? 'PHRS æ°´é¾™å¤´ - Goosebox' : 'PHRS Faucet - Goosebox');
            
            // æ›´æ–°å‰¯æ ‡é¢˜
            const subtitleElement = document.getElementById('subtitle');
            if (subtitleElement) {
                subtitleElement.textContent = langData.faucet?.subtitle || langData.subtitle;
            }
            
            // æ›´æ–°è‹±é›„åŒºåŸŸ
            document.getElementById('heroTitle').textContent = langData.faucet?.heroTitle || langData.hero.title;
            document.getElementById('heroDescription').textContent = langData.faucet?.heroDescription || langData.hero.description;
            
            // æ›´æ–°æ‰€æœ‰å¸¦æœ‰ data-lang å±æ€§çš„å…ƒç´ 
            const navElements = document.querySelectorAll('[data-lang]');
            navElements.forEach(element => {
                const langKey = element.getAttribute('data-lang');
                const keys = langKey.split('.');
                let value = langData;
                for (const key of keys) {
                    if (value && value[key]) {
                        value = value[key];
                    } else {
                        value = '';
                        break;
                    }
                }
                if (value) {
                    element.textContent = value;
                }
            });
            
            // ç‰¹æ®Šå¤„ç†ï¼šæ›´æ–°é’±åŒ…è¿æ¥çŠ¶æ€æ˜¾ç¤º
            updateWalletStatusDisplay();
            
            // ç‰¹æ®Šå¤„ç†ï¼šæ›´æ–°æ‰€æœ‰å½“å‰æ˜¾ç¤ºçš„çŠ¶æ€æ¶ˆæ¯
            updateAllStatusDisplays();
            
            // æ›´æ–°è¯­è¨€é€‰æ‹©å™¨
            const flagElement = document.getElementById('currentLangFlag');
            const nameElement = document.getElementById('currentLangName');
            
            if (flagElement && nameElement) {
                const config = getLanguageConfig();
                const flagCode = config[lang].flag;
                const name = config[lang].name;
                flagElement.className = `fi fi-${flagCode}`;
                nameElement.textContent = name;
            }
        }

        // ä¸“é—¨ç”¨äºæ›´æ–°é’±åŒ…çŠ¶æ€æ˜¾ç¤ºçš„å‡½æ•°
        function updateWalletStatusDisplay() {
            if (walletAddress && authToken) {
                // å¦‚æœé’±åŒ…å·²è¿æ¥ï¼Œé‡æ–°ç”ŸæˆçŠ¶æ€æ˜¾ç¤º
                const langData = getLanguageData(currentLang);
                const walletConnectedMsg = langData.faucet?.messages?.walletConnected || 'é’±åŒ…å·²è¿æ¥';
                showStatus('walletStatus', `${walletConnectedMsg}: ${formatAddress(walletAddress)}`, 'success');
                
                // æ ‡è®°ä¸ºè‡ªå®šä¹‰çŠ¶æ€ï¼ˆå› ä¸ºåŒ…å«åŠ¨æ€åœ°å€ï¼‰
                currentStatusStates.walletStatus = {
                    type: 'success',
                    messageKey: 'faucet.messages.walletConnected',
                    params: { address: walletAddress },
                    isCustom: true
                };
            }
        }

        // æ›´æ–°æ‰€æœ‰å½“å‰æ˜¾ç¤ºçš„çŠ¶æ€æ¶ˆæ¯
        function updateAllStatusDisplays() {
            Object.keys(currentStatusStates).forEach(elementId => {
                const state = currentStatusStates[elementId];
                if (state.messageKey && !state.isCustom) {
                    // é‡æ–°æ˜¾ç¤ºç®€å•çš„å¤šè¯­è¨€æ¶ˆæ¯
                    showStatusI18n(elementId, state.messageKey, state.type, state.params);
                } else if (state.isCustom && elementId === 'walletStatus' && walletAddress && authToken) {
                    // ç‰¹æ®Šå¤„ç†é’±åŒ…çŠ¶æ€
                    updateWalletStatusDisplay();
                }
            });
        }

        
        function renderLanguageSelector() {
            const container = document.getElementById('languageOptions');
            const config = getLanguageConfig();
            container.innerHTML = Object.entries(config).map(([code, lang]) => `
                <button class="w-full text-left px-4 py-2 hover:bg-wood-50 text-wood-900 transition-colors duration-150 ${code === currentLang ? 'bg-wood-100 text-wood-900 font-medium' : 'hover:text-wood-700'} flex items-center gap-3 rounded-md" 
                        onclick="switchLanguage('${code}')">
                    <span class="fi fi-${lang.flag} text-lg flex-shrink-0"></span>
                    <span class="truncate">${lang.name}</span>
                    ${code === currentLang ? '<span class="ml-auto text-wood-700 text-sm">âœ“</span>' : ''}
                </button>
            `).join('');
        }

        
        function switchLanguage(lang) {
            const config = getLanguageConfig();
            if (config[lang]) {
                currentLang = lang;
                localStorage.setItem('goosebox_lang', lang);
                updateLanguage(lang);
                renderLanguageSelector();
            }
        }

        
        function getLanguageData(lang) {
            // ä½¿ç”¨ languages.js ä¸­çš„è¯­è¨€åŒ…ï¼Œä½†è¦†ç›–æ°´é¾™å¤´ç‰¹å®šçš„å†…å®¹
            if (typeof languagePacks !== 'undefined' && languagePacks[lang]) {
                const baseLangData = languagePacks[lang];
                return {
                    ...baseLangData,
                    title: lang === 'zh' ? 'PHRS æ°´é¾™å¤´ - Goosebox' : 'PHRS Faucet - Goosebox',
                    hero: {
                        title: lang === 'zh' ? 'PHRS æ°´é¾™å¤´' : 'PHRS Faucet',
                        description: lang === 'zh' 
                            ? 'æ¯æ—¥å…è´¹é¢†å– 0.1 PHRS æµ‹è¯•ä»£å¸ï¼Œä½“éªŒ Goosebox ç”Ÿæ€ç³»ç»Ÿ'
                            : 'Claim 0.1 PHRS test tokens daily and experience the Goosebox ecosystem'
                    }
                };
            }
            
            // å¤‡ç”¨è¯­è¨€åŒ…ï¼ˆå¦‚æœ languages.js æœªåŠ è½½ï¼‰
            const fallbackPacks = {
                zh: {
                    title: 'PHRS æ°´é¾™å¤´ - Goosebox',
                    hero: {
                        title: 'PHRS æ°´é¾™å¤´',
                        description: 'æ¯æ—¥å…è´¹é¢†å– 0.1 PHRS æµ‹è¯•ä»£å¸ï¼Œä½“éªŒ Goosebox ç”Ÿæ€ç³»ç»Ÿ'
                    },
                    nav: {
                        home: 'é¦–é¡µ',
                        highlights: 'æ¸¸æˆç‰¹è‰²',
                        play: 'å¼€å§‹æ¸¸æˆ',
                        faq: 'å¸¸è§é—®é¢˜',
                        wallet: 'è¿æ¥é’±åŒ…'
                    }
                },
                en: {
                    title: 'PHRS Faucet - Goosebox',
                    hero: {
                        title: 'PHRS Faucet',
                        description: 'Claim 0.1 PHRS test tokens daily and experience the Goosebox ecosystem'
                    },
                    nav: {
                        home: 'Home',
                        highlights: 'Highlights',
                        play: 'Play Now',
                        faq: 'FAQ',
                        wallet: 'Connect Wallet'
                    }
                }
            };
            return fallbackPacks[lang] || fallbackPacks['zh'];
        }

        
        function getLanguageConfig() {
            if (typeof languageConfig !== 'undefined') {
                return languageConfig;
            }
            
            return {
                zh: { name: 'ä¸­æ–‡', flag: 'cn' },
                en: { name: 'English', flag: 'us' }
            };
        }

        
        function onFaucetRecaptchaSuccess(token) {
            faucetRecaptchaToken = token;
            console.log('æ°´é¾™å¤´ reCAPTCHA éªŒè¯æˆåŠŸ');
            checkClaimButtonState();
        }

        function onFaucetRecaptchaExpired() {
            faucetRecaptchaToken = null;
            console.log('æ°´é¾™å¤´ reCAPTCHA å·²è¿‡æœŸï¼Œè¯·é‡æ–°éªŒè¯');
            document.getElementById('claimTokens').disabled = true;
        }

        
        function checkClaimButtonState() {
            const hasAuth = authToken;
            const hasRecaptcha = faucetRecaptchaToken;
            const noCooldown = currentCooldownTime <= 0;

            
            if (noCooldown) {
                document.getElementById('claimTokens').disabled = !(hasAuth && hasRecaptcha);
            } else {
                
                document.getElementById('claimTokens').disabled = true;
            }
        }

        
        function checkEthersLoaded() {
            return new Promise((resolve, reject) => {
                if (typeof ethers !== 'undefined') {
                    resolve(true);
                    return;
                }


                let attempts = 0;
                const maxAttempts = 50;

                const checkInterval = setInterval(() => {
                    attempts++;

                    if (typeof ethers !== 'undefined') {
                        clearInterval(checkInterval);
                        resolve(true);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkInterval);
                        reject(new Error('ethers.js åŠ è½½è¶…æ—¶ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•'));
                    }
                }, 100);
            });
        }




        function showStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            if (!element) {
                console.error(`âŒ showStatus: æ‰¾ä¸åˆ°å…ƒç´  '${elementId}'`);
                return;
            }
            
            const statusClass = {
                'info': 'p-4 border rounded-lg bg-blue-50 border-blue-200 text-blue-800',
                'success': 'p-4 border rounded-lg bg-green-50 border-green-200 text-green-800',
                'error': 'p-4 border rounded-lg bg-red-50 border-red-200 text-red-800',
                'warning': 'p-4 border rounded-lg bg-yellow-50 border-yellow-200 text-yellow-800'
            };
            
            element.innerHTML = `<div class="${statusClass[type]}">${message}</div>`;
            
            // å¦‚æœè¿™æ˜¯ä¸€ä¸ªç›´æ¥çš„showStatusè°ƒç”¨ï¼ˆä¸æ˜¯æ¥è‡ªshowStatusI18nï¼‰ï¼Œæ ‡è®°ä¸ºè‡ªå®šä¹‰
            if (currentStatusStates[elementId] && !showStatus.fromI18n) {
                currentStatusStates[elementId] = {
                    type: type,
                    messageKey: null,
                    params: null,
                    isCustom: true
                };
            }
        }

        // å¤šè¯­è¨€åŒ–çš„showStatuså‡½æ•°
        function showStatusI18n(elementId, messageKey, type = 'info', params = {}) {
            const langData = getLanguageData(currentLang);
            const keys = messageKey.split('.');
            let message = langData;
            for (const key of keys) {
                if (message && message[key]) {
                    message = message[key];
                } else {
                    message = messageKey; // å›é€€åˆ°åŸå§‹key
                    break;
                }
            }
            
            // æ”¯æŒå‚æ•°æ›¿æ¢
            if (typeof message === 'string') {
                Object.keys(params).forEach(key => {
                    message = message.replace(`{${key}}`, params[key]);
                });
            }
            
            // è®°å½•çŠ¶æ€ä¿¡æ¯ç”¨äºè¯­è¨€åˆ‡æ¢æ—¶æ›´æ–°
            if (currentStatusStates[elementId]) {
                currentStatusStates[elementId] = {
                    type: type,
                    messageKey: messageKey,
                    params: params,
                    isCustom: false
                };
            }
            
            // æ ‡è®°è¿™ä¸ªè°ƒç”¨æ¥è‡ªshowStatusI18n
            showStatus.fromI18n = true;
            showStatus(elementId, message, type);
            showStatus.fromI18n = false;
        }

        // è·å–å¤šè¯­è¨€æ¶ˆæ¯çš„è¾…åŠ©å‡½æ•°
        function getI18nMessage(messageKey, fallback = '') {
            const langData = getLanguageData(currentLang);
            const keys = messageKey.split('.');
            let message = langData;
            for (const key of keys) {
                if (message && message[key]) {
                    message = message[key];
                } else {
                    return fallback || messageKey;
                }
            }
            return message;
        }

        function formatAddress(address) {
            return `<span class="font-mono bg-gray-100 px-2 py-1 rounded text-sm">${address.slice(0, 6)}...${address.slice(-4)}</span>`;
        }




        function formatCountdown(seconds) {
            if (seconds <= 0) return '';

            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;

            if (hours > 0) {
                return `${hours}å°æ—¶${minutes}åˆ†é’Ÿ`;
            } else if (minutes > 0) {
                return `${minutes}åˆ†${secs}ç§’`;
            } else {
                return `${secs}ç§’`;
            }
        }


        function startCountdown(remainingSeconds) {

            if (countdownTimer) {
                clearInterval(countdownTimer);
            }

            currentCooldownTime = remainingSeconds;

            if (remainingSeconds <= 0) {

                enableClaimButton();
                return;
            }


            disableClaimButton();
            updateCountdownDisplay();

            countdownTimer = setInterval(() => {
                currentCooldownTime--;

                if (currentCooldownTime <= 0) {
                    clearInterval(countdownTimer);
                    enableClaimButton();
                } else {
                    updateCountdownDisplay();
                }
            }, 1000);
        }


        function updateCountdownDisplay() {
            const countdownElement = document.getElementById('claimCountdown');
            const buttonTextElement = document.getElementById('claimButtonText');

            if (currentCooldownTime > 0) {
                buttonTextElement.style.display = 'none';
                countdownElement.style.display = 'inline';
                countdownElement.textContent = `å†·å´ä¸­ (${formatCountdown(currentCooldownTime)})`;
            } else {
                buttonTextElement.style.display = 'inline';
                countdownElement.style.display = 'none';
            }
        }


        function enableClaimButton() {
            const button = document.getElementById('claimTokens');
            const buttonTextElement = document.getElementById('claimButtonText');
            const countdownElement = document.getElementById('claimCountdown');

            button.disabled = false;
            buttonTextElement.style.display = 'inline';
            buttonTextElement.textContent = 'é¢†å–ä»£å¸';
            countdownElement.style.display = 'none';


            checkClaimButtonState();
        }


        function disableClaimButton() {
            const button = document.getElementById('claimTokens');
            button.disabled = true;
        }

        document.getElementById('connectTwitter').addEventListener('click', async () => {
            try {
                
                const currentToken = localStorage.getItem('faucetAuthToken') || authToken;
                
                if (!currentToken) {
                    showStatusI18n('twitterOAuthStatus', 'faucet.messages.authRequired', 'error');
                    return;
                }

                // æ­¥éª¤1: é¦–å…ˆæ£€æŸ¥ Twitter çŠ¶æ€
                showStatusI18n('twitterOAuthStatus', 'faucet.messages.checkingTwitterStatus', 'info');
                
                const statusResponse = await fetch(`${API_BASE}/twitter/status`, {
                    credentials: 'include',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });
                const statusData = await statusResponse.json();

                if (!statusResponse.ok) {
                    // å¦‚æœçŠ¶æ€æ£€æŸ¥è¿”å›401æˆ–éœ€è¦ç™»å½•çš„é”™è¯¯
                    if (statusResponse.status === 401 || 
                        (statusData.message && statusData.message.includes('login')) ||
                        (statusData.error && statusData.error.includes('Unauthorized'))) {
                        
                        showStatusI18n('twitterOAuthStatus', 'faucet.messages.autoReloginDetected', 'info');
                        
                        // æ­¥éª¤2a: è·å–æ–°çš„nonce
                        showStatusI18n('twitterOAuthStatus', 'faucet.messages.gettingNonce', 'info');
                        
                        const nonceResponse = await fetch(`${API_BASE}/nonce`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            credentials: 'include',
                            body: JSON.stringify({ walletAddress })
                        });

                        const nonceData = await nonceResponse.json();
                        
                        if (!nonceData.success) {
                            throw new Error(`è·å–nonceå¤±è´¥: ${nonceData.message || nonceData.error}`);
                        }

                        const nonce = nonceData.data.nonce;
                        const message = nonceData.data.message;

                        // æ­¥éª¤2b: è¯·æ±‚ç”¨æˆ·ç­¾å
                        showStatusI18n('twitterOAuthStatus', 'faucet.messages.requestingSignature', 'info');
                        
                        const signature = await window.ethereum.request({
                            method: 'personal_sign',
                            params: [message, walletAddress]
                        });

                        // æ­¥éª¤2c: ä½¿ç”¨ç­¾åç™»å½•
                        showStatusI18n('twitterOAuthStatus', 'faucet.messages.verifyingSignature', 'info');
                        
                        const loginResponse = await fetch(`${API_BASE}/login`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                walletAddress,
                                signature,
                                message
                            })
                        });

                        const loginData = await loginResponse.json();
                        
                        if (!loginData.success) {
                            throw new Error(`è‡ªåŠ¨ç™»å½•å¤±è´¥: ${loginData.message || loginData.error}`);
                        }

                        showStatusI18n('twitterOAuthStatus', 'faucet.messages.autoLoginSuccess', 'info');
                        
                        // æ›´æ–°token
                        authToken = loginData.data.token;
                        localStorage.setItem('faucetAuthToken', authToken);
                        localStorage.setItem('faucetUser', JSON.stringify(loginData.data.user));
                    } else {
                        throw new Error(statusData.message || statusData.error || 'çŠ¶æ€æ£€æŸ¥å¤±è´¥');
                    }
                } else {
                    // çŠ¶æ€æ£€æŸ¥æˆåŠŸ
                    const { connected, twitter } = statusData.data;

                                if (connected && twitter) {
                        const twitterConnectedMsg = getI18nMessage('faucet.messages.twitterAlreadyConnected', 'âœ… Twitter å·²ç»è¿æ¥!');
                        const twitterInfoMsg = getI18nMessage('faucet.messages.twitterInfo', 'Twitter ä¿¡æ¯:');
                        const usernameMsg = getI18nMessage('faucet.messages.username', 'ç”¨æˆ·å');
                        const displayNameMsg = getI18nMessage('faucet.messages.displayName', 'æ˜¾ç¤ºå');
                        const verifiedMsg = getI18nMessage('faucet.messages.verified', 'éªŒè¯çŠ¶æ€');
                        const followersMsg = getI18nMessage('faucet.messages.followers', 'å…³æ³¨è€…');
                        const connectedAtMsg = getI18nMessage('faucet.messages.connectedAt', 'è¿æ¥æ—¶é—´');
                        const verifiedStatusMsg = twitter.verified ? 
                            getI18nMessage('faucet.messages.verified_', 'å·²éªŒè¯') : 
                            getI18nMessage('faucet.messages.unverified', 'æœªéªŒè¯');
                        
                        showStatus('twitterStatus',
                            `${twitterConnectedMsg}<br><br>` +
                            `<div class="bg-gray-50 p-3 rounded">` +
                            `<strong>${twitterInfoMsg}</strong><br>` +
                            `${usernameMsg}: @${twitter.username}<br>` +
                            `${displayNameMsg}: ${twitter.name}<br>` +
                            `${verifiedMsg}: ${verifiedStatusMsg}<br>` +
                            `${followersMsg}: ${twitter.publicMetrics?.followers_count || 0}<br>` +
                            `${connectedAtMsg}: ${new Date(twitter.connectedAt).toLocaleString()}` +
                            `</div>`,
                            'success'
                        );

                    document.getElementById('connectTwitter').style.display = 'none';
                    document.getElementById('disconnectTwitter').style.display = 'inline-block';
                    document.getElementById('disconnectTwitter').disabled = false;
                        
                        // Twitterè¿æ¥æˆåŠŸåï¼Œéšè—Twitter OAuth sectionï¼Œæ˜¾ç¤ºçŠ¶æ€éƒ¨åˆ†
                        hideTwitterSection();
                        showTwitterStatusSection();
                        return;
                    }
                    
                    showStatusI18n('twitterOAuthStatus', 'faucet.messages.statusCheckPassed', 'info');
                }

                // æ­¥éª¤3: æ£€æŸ¥æœåŠ¡å™¨ç«¯TwitteræœåŠ¡çŠ¶æ€
                const preCheckResponse = await fetch(`${API_BASE}/twitter/health`, {
                    method: 'GET',
                    credentials: 'include',
                    headers: {
                        'Authorization': `Bearer ${currentToken}`
                    }
                });

                // å¦‚æœæœ‰å¥åº·æ£€æŸ¥APIï¼Œä½¿ç”¨å®ƒæ¥æ£€æŸ¥
                if (preCheckResponse.status === 404) {
                    // å¦‚æœæ²¡æœ‰å¥åº·æ£€æŸ¥APIï¼Œç›´æ¥è·³è½¬ï¼ˆå‘åå…¼å®¹ï¼‰
                    console.log('æ²¡æœ‰å¥åº·æ£€æŸ¥APIï¼Œç›´æ¥è·³è½¬');
                } else if (!preCheckResponse.ok) {
                    // å¦‚æœæœ‰å¥åº·æ£€æŸ¥APIä½†è¿”å›é”™è¯¯
                    try {
                        const errorData = await preCheckResponse.json();
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯é¢‘ç‡é™åˆ¶é”™è¯¯
                        if (errorData.error && (errorData.error.includes('Too many requests') || errorData.error.includes('rate'))) {
                            showStatusI18n('twitterOAuthStatus', 'faucet.messages.tooManyRequests', 'warning');
                            return; // ä¸è·³è½¬
                        } else {
                            showStatusI18n('twitterOAuthStatus', 'faucet.messages.serviceUnavailable', 'error');
                            return; // ä¸è·³è½¬
                        }
                    } catch (parseError) {
                        // å¦‚æœè§£æé”™è¯¯å“åº”å¤±è´¥ï¼Œç›´æ¥è·³è½¬
                        console.log('è§£æå¥åº·æ£€æŸ¥å“åº”å¤±è´¥ï¼Œç›´æ¥è·³è½¬');
                    }
                }

                // å¦‚æœå¥åº·æ£€æŸ¥é€šè¿‡æˆ–æ²¡æœ‰å¥åº·æ£€æŸ¥APIï¼Œè·³è½¬åˆ°æˆæƒé¡µé¢
                window.location.href = `${API_BASE}/twitter`;
                
            } catch (error) {
                console.error('Twitter è¿æ¥æµç¨‹å¤±è´¥:', error);
                
                // ç‰¹æ®Šå¤„ç†ç”¨æˆ·å–æ¶ˆç­¾åçš„æƒ…å†µ
                if (error.message && error.message.includes('User rejected')) {
                    showStatusI18n('twitterOAuthStatus', 'faucet.messages.userCancelledSignature', 'warning');
                } else {
                    const connectionFailedMsg = getI18nMessage('faucet.messages.twitterConnectionFailed', 'âŒ X è¿æ¥å¤±è´¥');
                    showStatus('twitterOAuthStatus', 
                        `${connectionFailedMsg}: ${error.message}`, 
                        'error'
                    );
                }
            }
        });

        document.getElementById('disconnectTwitter').addEventListener('click', async () => {
            try {
                showStatusI18n('twitterStatus', 'faucet.messages.disconnectingTwitter', 'info');

                const response = await fetch(`${API_BASE}/twitter/disconnect`, {
                    method: 'POST',
                    credentials: 'include'
                });

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.message || data.error);
                }

                const twitterDisconnectedMsg = getI18nMessage('faucet.messages.twitterDisconnected', 'Twitter è¿æ¥å·²æ–­å¼€!');
                const faucetUserMsg = getI18nMessage('faucet.messages.faucetUser', 'æ°´é¾™å¤´ç”¨æˆ·:');
                const walletMsg = getI18nMessage('faucet.messages.wallet', 'é’±åŒ…');
                const usernameMsg = getI18nMessage('faucet.messages.username', 'ç”¨æˆ·å');
                
                showStatus('twitterStatus',
                    `${twitterDisconnectedMsg}<br><br>` +
                    `<div class="bg-gray-50 p-3 rounded">` +
                    `<strong>${faucetUserMsg}</strong><br>` +
                    `${walletMsg}: ${formatAddress(data.data.faucetUser.walletAddress)}<br>` +
                    `${usernameMsg}: ${data.data.faucetUser.username}` +
                    `</div>`,
                    'success'
                );

                document.getElementById('connectTwitter').style.display = 'inline-block';
                document.getElementById('disconnectTwitter').style.display = 'none';
                
                // Twitteræ–­å¼€è¿æ¥åï¼Œæ˜¾ç¤ºTwitter OAuth sectionï¼Œéšè—çŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½
                showTwitterSection();
                hideTwitterStatusSection();
                hideFaucetClaimSection();
                
            } catch (error) {
                // ç¡®ä¿ Twitter çŠ¶æ€éƒ¨åˆ†å¯è§ä»¥æ˜¾ç¤ºé”™è¯¯
                showTwitterStatusSection();
                
                const disconnectFailedMsg = getLanguageData(currentLang).faucet?.messages?.twitterDisconnectFailed || 'æ–­å¼€ Twitter è¿æ¥å¤±è´¥';
                showStatus('twitterStatus', `${disconnectFailedMsg}: ${error.message}`, 'error');
            }
        });



        document.getElementById('checkFaucetStatus').addEventListener('click', async () => {
            try {
                showStatusI18n('faucetStatus', 'faucet.messages.checkingFaucetStatus', 'info');

                const token = localStorage.getItem('faucetAuthToken') || authToken;
                if (!token) {
                    throw new Error('è¯·å…ˆç™»å½•');
                }

                const response = await fetch(`${API_BASE}/claim/status`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    credentials: 'include'
                });

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.message || data.error);
                }

                const { canClaim, user, ip, twitter, rateLimit } = data.data;

                let statusHtml = `<div class="bg-gray-50 p-3 rounded">`;
                statusHtml += `<strong>é¢†å–çŠ¶æ€:</strong> ${canClaim ? 'å¯ä»¥é¢†å–' : 'æš‚æ—¶æ— æ³•é¢†å–'}<br><br>`;

                statusHtml += `<strong>ç”¨æˆ·çŠ¶æ€:</strong><br>`;
                statusHtml += `åœ°å€: ${user.address.slice(0,6)}...${user.address.slice(-4)}<br>`;
                statusHtml += `å¯é¢†å–: ${user.canClaim ? 'æ˜¯' : 'å¦'}<br>`;
                if (user.remainingTime) {
                    statusHtml += `å†·å´å‰©ä½™: ${Math.floor(user.remainingTime / 3600)}å°æ—¶${Math.floor((user.remainingTime % 3600) / 60)}åˆ†é’Ÿ<br>`;
                }

                statusHtml += `<br><strong>IP çŠ¶æ€:</strong><br>`;
                statusHtml += `åœ°å€: ${ip.address}<br>`;
                statusHtml += `å¯é¢†å–: ${ip.canClaim ? 'æ˜¯' : 'å¦'}<br>`;
                if (ip.remainingTime) {
                    statusHtml += `å†·å´å‰©ä½™: ${Math.floor(ip.remainingTime / 3600)}å°æ—¶${Math.floor((ip.remainingTime % 3600) / 60)}åˆ†é’Ÿ<br>`;
                }

                statusHtml += `<br><strong>Twitter çŠ¶æ€:</strong><br>`;
                statusHtml += `ç»‘å®šçŠ¶æ€: ${twitter.isBound ? 'å·²ç»‘å®š' : 'æœªç»‘å®š'}<br>`;
                if (twitter.username) {
                    statusHtml += `ç”¨æˆ·å: @${twitter.username}<br>`;
                }
                if (twitter.isBound) {
                    statusHtml += `å¯é¢†å–: ${twitter.canClaim ? 'æ˜¯' : 'å¦'}<br>`;
                    if (twitter.remainingTime) {
                        statusHtml += `å†·å´å‰©ä½™: ${Math.floor(twitter.remainingTime / 3600)}å°æ—¶${Math.floor((twitter.remainingTime % 3600) / 60)}åˆ†é’Ÿ<br>`;
                    }
                }

                statusHtml += `<br><strong>é€Ÿç‡é™åˆ¶:</strong><br>`;
                statusHtml += `å…è®¸è¯·æ±‚: ${rateLimit.allowed ? 'æ˜¯' : 'å¦'}<br>`;
                statusHtml += `å‰©ä½™æ¬¡æ•°: ${rateLimit.remaining}<br>`;
                statusHtml += `</div>`;

                showStatus('faucetStatus', statusHtml, canClaim ? 'success' : 'error');

                let maxCooldownTime = 0;
                if (user.remainingTime && user.remainingTime > 0) {
                    maxCooldownTime = Math.max(maxCooldownTime, user.remainingTime);
                }
                if (ip.remainingTime && ip.remainingTime > 0) {
                    maxCooldownTime = Math.max(maxCooldownTime, ip.remainingTime);
                }
                if (twitter.remainingTime && twitter.remainingTime > 0) {
                    maxCooldownTime = Math.max(maxCooldownTime, twitter.remainingTime);
                }

                startCountdown(maxCooldownTime);

            } catch (error) {
                const checkFailedMsg = getLanguageData(currentLang).faucet?.messages?.faucetCheckFailed || 'æ£€æŸ¥æ°´é¾™å¤´çŠ¶æ€å¤±è´¥';
                showStatus('faucetStatus', `${checkFailedMsg}: ${error.message}`, 'error');
            }
        });

        document.getElementById('claimTokens').addEventListener('click', async () => {
            try {
                if (!faucetRecaptchaToken) {
                    showStatusI18n('faucetStatus', 'faucet.errors.recaptchaRequired', 'error');
                return;
            }

                if (typeof window.ethereum === 'undefined') {
                    showStatusI18n('faucetStatus', 'faucet.errors.walletRequired', 'error');
                return;
            }

                showStatusI18n('faucetStatus', 'faucet.messages.gettingSignature', 'info');

                const token = localStorage.getItem('faucetAuthToken') || authToken;
                if (!token) {
                    throw new Error('è¯·å…ˆç™»å½•');
                }

                const response = await fetch(`${API_BASE}/claim/signature`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        recaptchaToken: faucetRecaptchaToken
                    })
                });

                const data = await response.json();

                console.log('è·å–ç­¾åå“åº”:', data);

                if (!data.success) {
                    let errorDetails = {
                        message: data.message || data.error,
                        fullResponse: data
                    };

                    const error = new Error(data.message || data.error);
                    error.details = errorDetails;
                    throw error;
                }

                const { signature, params, domain, twitter, rateLimit } = data.data;

                showStatus('faucetStatus',
                    `ç­¾åè·å–æˆåŠŸï¼Œæ­£åœ¨è°ƒç”¨åˆçº¦...<br><br>` +
                    `<div class="bg-gray-50 p-3 rounded">` +
                    `<strong>é¢†å–ä¿¡æ¯:</strong><br>` +
                    `é‡‘é¢: ${parseFloat(params.amount) / 1e18} PHRS<br>` +
                    `Twitter: @${twitter.username}<br>` +
                    `å‰©ä½™è¯·æ±‚: ${rateLimit.remaining}<br>` +
                    `</div>`,
                    'info'
                );

                await callFaucetContract(signature, params);

                if (typeof grecaptcha !== 'undefined') {
                    grecaptcha.reset();
                    faucetRecaptchaToken = null;
                    checkClaimButtonState();
                }

            } catch (error) {
                console.error('è·å–ç­¾åå®Œæ•´é”™è¯¯ä¿¡æ¯:', error);

                let errorMessage = `è·å–ç­¾åå¤±è´¥: ${error.message}`;

                if (error.message.includes('IP address can claim again')) {
                    fetch('https://api.ipify.org?format=json')
                        .then(response => response.json())
                        .then(data => {
                            const currentIP = data.ip;

                            let debugInfo = '';
                            if (error.details && error.details.fullResponse) {
                                debugInfo = `<br><br><strong>è°ƒè¯•ä¿¡æ¯:</strong><br>` +
                                           `<div class="bg-gray-100 p-2 rounded text-xs" style="max-height: 200px; overflow-y: auto;">` +
                                           `${JSON.stringify(error.details.fullResponse, null, 2)}` +
                                           `</div>`;
                            }

                            showStatus('faucetStatus',
                                `è·å–ç­¾åå¤±è´¥: ${error.message}<br><br>` +
                                `<div class="bg-gray-50 p-3 rounded">` +
                                `<strong>å½“å‰IPåœ°å€:</strong> ${currentIP}<br>` +
                                `<strong>çŠ¶æ€:</strong> å†·å´æœŸä¸­ï¼Œè¯·ç­‰å¾…å†·å´æ—¶é—´ç»“æŸ<br>` +
                                `</div>` +
                                debugInfo,
                                'error'
                            );
                        })
                        .catch(ipError => {
                            showStatus('faucetStatus', errorMessage, 'error');
                        });
                } else {
                    let debugInfo = '';
                    if (error.details && error.details.fullResponse) {
                        debugInfo = `<br><br><strong>è°ƒè¯•ä¿¡æ¯:</strong><br>` +
                                   `<div class="bg-gray-100 p-2 rounded text-xs" style="max-height: 200px; overflow-y: auto;">` +
                                   `${JSON.stringify(error.details.fullResponse, null, 2)}` +
                                   `</div>`;
                    }

                    showStatus('faucetStatus', errorMessage + debugInfo, 'error');
                }

                if (typeof grecaptcha !== 'undefined') {
                    grecaptcha.reset();
                    faucetRecaptchaToken = null;
                    checkClaimButtonState();
                }
            }
        });

        async function callFaucetContract(signature, params) {
            try {
                showStatusI18n('faucetStatus', 'faucet.messages.checkingDependencies', 'info');
                await checkEthersLoaded();



                const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                if (accounts.length === 0) {
                    throw new Error('è¯·å…ˆè¿æ¥ AppKit é’±åŒ…');
                }

                const userAccount = accounts[0];
                if (userAccount.toLowerCase() !== params.user.toLowerCase()) {
                    throw new Error('å½“å‰é’±åŒ…åœ°å€ä¸ç­¾ååœ°å€ä¸åŒ¹é…');
                }

                showStatusI18n('faucetStatus', 'faucet.messages.contractCalling', 'info');

                const provider = new ethers.providers.Web3Provider(window.ethereum);
                const signer = provider.getSigner();
                const contract = new ethers.Contract(FAUCET_CONTRACT_ADDRESS, FAUCET_ABI, signer);

                const tx = await contract.claimTokens(
                    params.amount,
                    params.nonce,
                    params.timestamp,
                    params.ip,
                    params.twitterId,
                    signature
                );

                    showStatus('faucetStatus', 
                    `äº¤æ˜“å·²æäº¤ï¼Œç­‰å¾…ç¡®è®¤...<br><br>` +
                    `<div class="bg-gray-50 p-3 rounded">` +
                    `äº¤æ˜“å“ˆå¸Œ: <div class="bg-gray-100 p-2 mt-1 rounded text-sm font-mono break-all">${tx.hash}</div>` +
                    `</div>`,
                    'info'
                );

                const receipt = await tx.wait();

                showStatusI18n('faucetStatus', 'faucet.messages.notifyingServer', 'info');

                try {
                    const confirmResponse = await fetch(`${API_BASE}/claim/confirm`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        credentials: 'include',
                        body: JSON.stringify({
                            nonce: params.nonce,
                            txHash: receipt.transactionHash,
                            success: true
                        })
                    });

                    const confirmData = await confirmResponse.json();

                    if (confirmData.success) {
                        console.log('æœåŠ¡å™¨ç¡®è®¤æˆåŠŸ:', confirmData);

                        showStatus('faucetStatus',
                            `ä»£å¸é¢†å–æˆåŠŸï¼<br><br>` +
                            `<div class="bg-gray-50 p-3 rounded">` +
                            `<strong>äº¤æ˜“ä¿¡æ¯:</strong><br>` +
                            `äº¤æ˜“å“ˆå¸Œ: <div class="bg-gray-100 p-2 mt-1 rounded text-sm font-mono break-all">${receipt.transactionHash}</div><br>` +
                            `åŒºå—å·: ${receipt.blockNumber}<br>` +
                            `Gas ä½¿ç”¨: ${receipt.gasUsed.toString()}<br>` +
                            `é¢†å–é‡‘é¢: 0.1 PHRS<br><br>` +
                            `<strong>é¢†å–æˆåŠŸï¼</strong><br>` +
                            `<strong>24å°æ—¶å†·å´æœŸå·²å¼€å§‹</strong>` +
                            `</div>`,
                            'success'
                        );

                    startCountdown(86400);
                    
                    } else {
                        console.warn('æœåŠ¡å™¨ç¡®è®¤å¤±è´¥:', confirmData);
                        showStatus('faucetStatus',
                            `ä»£å¸é¢†å–æˆåŠŸï¼Œä½†æœåŠ¡å™¨ç¡®è®¤å¤±è´¥<br><br>` +
                            `<div class="bg-gray-50 p-3 rounded">` +
                            `äº¤æ˜“å“ˆå¸Œ: <div class="bg-gray-100 p-2 mt-1 rounded text-sm font-mono break-all">${receipt.transactionHash}</div><br>` +
                            `é”™è¯¯: ${confirmData.error || confirmData.message}<br><br>` +
                            `<strong>æ³¨æ„:</strong> ä»£å¸å·²æˆåŠŸé¢†å–ï¼Œä½†å†·å´æœŸå¯èƒ½æœªæ­£ç¡®è®¾ç½®` +
                            `</div>`,
                            'warning'
                        );
                    }
                } catch (confirmError) {
                    console.error('ç¡®è®¤æ¥å£è°ƒç”¨å¤±è´¥:', confirmError);
                    showStatus('faucetStatus',
                        `ä»£å¸é¢†å–æˆåŠŸï¼Œä½†æœåŠ¡å™¨é€šçŸ¥å¤±è´¥<br><br>` +
                        `<div class="bg-gray-50 p-3 rounded">` +
                        `äº¤æ˜“å“ˆå¸Œ: <div class="bg-gray-100 p-2 mt-1 rounded text-sm font-mono break-all">${receipt.transactionHash}</div><br>` +
                        `ç¡®è®¤é”™è¯¯: ${confirmError.message}<br><br>` +
                        `<strong>æ³¨æ„:</strong> ä»£å¸å·²æˆåŠŸé¢†å–ï¼Œä½†å†·å´æœŸå¯èƒ½æœªæ­£ç¡®è®¾ç½®` +
                        `</div>`,
                        'warning'
                    );
                }
                    
                    if (typeof grecaptcha !== 'undefined') {
                        grecaptcha.reset();
                        faucetRecaptchaToken = null;
                        checkClaimButtonState();
                    }
                
            } catch (error) {
                console.error('åˆçº¦è°ƒç”¨å¤±è´¥:', error);

                let errorMessage = error.message;
                let shouldNotifyServer = false;
                let txHash = null;

                if (error.code === 4001) {
                    errorMessage = 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“';
                } else if (error.message.includes('insufficient funds')) {
                    errorMessage = 'è´¦æˆ·ä½™é¢ä¸è¶³æ”¯ä»˜ Gas è´¹ç”¨';
                } else if (error.message.includes('CooldownNotMet')) {
                    errorMessage = 'å†·å´æœŸæœªæ»¡ï¼Œè¯·24å°æ—¶åå†è¯•';
                } else if (error.message.includes('InvalidSignature')) {
                    errorMessage = 'ç­¾åéªŒè¯å¤±è´¥';
                } else if (error.message.includes('NonceAlreadyUsed')) {
                    errorMessage = 'ç­¾åå·²è¢«ä½¿ç”¨';
                }

                if (error.transaction && error.transaction.hash) {
                    shouldNotifyServer = true;
                    txHash = error.transaction.hash;
                    errorMessage += `<br>äº¤æ˜“å“ˆå¸Œ: ${txHash}`;
                }

                showStatus('faucetStatus', `åˆçº¦è°ƒç”¨å¤±è´¥: ${errorMessage}`, 'error');

                if (shouldNotifyServer && txHash) {
                    try {
                        const confirmResponse = await fetch(`${API_BASE}/claim/confirm`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${authToken}`
                            },
                            credentials: 'include',
                            body: JSON.stringify({
                                nonce: params.nonce,
                                txHash: txHash,
                                success: false
                            })
                        });

                        const confirmData = await confirmResponse.json();
                        console.log('æœåŠ¡å™¨å·²ç¡®è®¤äº¤æ˜“å¤±è´¥:', confirmData);
                    } catch (confirmError) {
                        console.error('é€šçŸ¥æœåŠ¡å™¨äº¤æ˜“å¤±è´¥æ—¶å‡ºé”™:', confirmError);
                    }
                }

                throw error;
            }
        }

        async function handleTwitterCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const state = urlParams.get('state');
            const code = urlParams.get('code');
            const error = urlParams.get('error');
            const message = urlParams.get('message');

            console.log('ğŸ” Twitter å›è°ƒå¤„ç†å¼€å§‹:', { state, code, error, message });

            if (error) {
                // æˆæƒå¤±è´¥æ—¶ï¼Œæ˜¾ç¤ºè¿æ¥éƒ¨åˆ†å¹¶åœ¨é‚£é‡Œæ˜¾ç¤ºé”™è¯¯
                showTwitterSection();
                hideTwitterStatusSection();
                
                const twitterAuthFailedMsg = getI18nMessage('faucet.messages.twitterAuthFailed', 'Twitter æˆæƒå¤±è´¥');
                showStatus('twitterOAuthStatus', `${twitterAuthFailedMsg}: ${decodeURIComponent(message || error)}`, 'error');
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }

            if (state && code) {
                console.log('âœ… æ£€æµ‹åˆ° Twitter æˆæƒå›è°ƒå‚æ•°');
                
                // æ˜¾ç¤ºå›è°ƒçŠ¶æ€æç¤º
                const callbackStatus = document.getElementById('twitterCallbackStatus');
                const callbackDetails = document.getElementById('twitterCallbackDetails');
                if (callbackStatus && callbackDetails) {
                    callbackStatus.style.display = 'block';
                    callbackDetails.textContent = 'æ£€æµ‹åˆ°æˆæƒå›è°ƒï¼Œæ­£åœ¨å¤„ç†...';
                }
                
                showStatusI18n('twitterOAuthStatus', 'faucet.messages.bindingTwitterAccount', 'info');

                try {
                    const currentToken = localStorage.getItem('faucetAuthToken') || authToken;
                    console.log('ğŸ”‘ å½“å‰è®¤è¯çŠ¶æ€:', {
                        localStorageToken: !!localStorage.getItem('faucetAuthToken'),
                        authToken: !!authToken,
                        currentToken: !!currentToken
                    });

                    if (!currentToken) {
                        const errorMsg = 'æœªæ‰¾åˆ°è®¤è¯ Tokenï¼Œè¯·å…ˆå®Œæˆé’±åŒ…è¿æ¥å’Œç­¾åè®¤è¯';
                        console.error('âŒ Twitter ç»‘å®šå¤±è´¥:', errorMsg);
                        
                        
                        // æ›´æ–°å›è°ƒçŠ¶æ€æç¤º
                        if (callbackDetails) {
                            callbackDetails.textContent = 'è®¤è¯å¤±è´¥ï¼šéœ€è¦å…ˆå®Œæˆé’±åŒ…è¿æ¥å’Œç­¾å';
                        }
                        
                        showStatusI18n('twitterOAuthStatus', 'faucet.messages.authRequired', 'warning');
                        return;
                    }

                    console.log('ğŸ” ä½¿ç”¨ JWT Token è¿›è¡Œ Twitter ç»‘å®š:', currentToken.substring(0, 20) + '...');

                    const response = await fetch(`${API_BASE}/twitter/bind`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${currentToken}`
                        },
                        credentials: 'include',
                        body: JSON.stringify({ state, code })
                    });

                    console.log('ğŸ“¡ Twitter ç»‘å®š API å“åº”çŠ¶æ€:', response.status);
                    const data = await response.json();
                    console.log('ğŸ“¡ Twitter ç»‘å®š API å“åº”æ•°æ®:', data);

                    if (data.success) {
                        const twitter = data.data.twitter;
                        
                        // æ›´æ–°å›è°ƒçŠ¶æ€æç¤º
                        if (callbackDetails) {
                            callbackDetails.textContent = 'ç»‘å®šæˆåŠŸï¼';
                        }
                        
                        const bindingSuccessMsg = getI18nMessage('faucet.messages.twitterBindingSuccess', 'Twitter è´¦æˆ·ç»‘å®šæˆåŠŸ!');
                        const twitterInfoMsg = getI18nMessage('faucet.messages.twitterInfo', 'Twitter ä¿¡æ¯:');
                        const usernameMsg = getI18nMessage('faucet.messages.username', 'ç”¨æˆ·å');
                        const displayNameMsg = getI18nMessage('faucet.messages.displayName', 'æ˜¾ç¤ºå');
                        const verifiedMsg = getI18nMessage('faucet.messages.verified', 'éªŒè¯çŠ¶æ€');
                        const followersMsg = getI18nMessage('faucet.messages.followers', 'å…³æ³¨è€…');
                        const connectedAtMsg = getI18nMessage('faucet.messages.connectedAt', 'ç»‘å®šæ—¶é—´');
                        const verifiedStatusMsg = twitter.verified ? 
                            getI18nMessage('faucet.messages.verified_', 'å·²éªŒè¯') : 
                            getI18nMessage('faucet.messages.unverified', 'æœªéªŒè¯');

                        showStatus('twitterStatus',
                            `${bindingSuccessMsg}<br><br>` +
                            `<div class="bg-gray-50 p-3 rounded">` +
                            `<strong>${twitterInfoMsg}</strong><br>` +
                            `${usernameMsg}: @${twitter.username}<br>` +
                            `${displayNameMsg}: ${twitter.name}<br>` +
                            `${verifiedMsg}: ${verifiedStatusMsg}<br>` +
                            `${followersMsg}: ${twitter.publicMetrics?.followers_count || 0}<br>` +
                            `${connectedAtMsg}: ${new Date(twitter.connectedAt).toLocaleString()}` +
                            `</div>`,
                            'success'
                        );

                        document.getElementById('connectTwitter').style.display = 'none';
                        document.getElementById('disconnectTwitter').style.display = 'inline-block';
                        document.getElementById('disconnectTwitter').disabled = false;
                        
                        // Twitterç»‘å®šæˆåŠŸåï¼Œéšè—Twitter OAuth sectionï¼Œæ˜¾ç¤ºçŠ¶æ€éƒ¨åˆ†
                        hideTwitterSection();
                        showTwitterStatusSection();
                        
                        // éšè—å›è°ƒçŠ¶æ€æç¤º
                        if (callbackStatus) {
                            callbackStatus.style.display = 'none';
                        }
                    } else {
                        throw new Error(data.message || data.error);
                    }

                } catch (error) {
                    console.error('âŒ Twitter è´¦æˆ·ç»‘å®šå¤±è´¥:', error);
                    
                    // ç»‘å®šå¤±è´¥æ—¶ï¼Œåº”è¯¥éšè—çŠ¶æ€éƒ¨åˆ†ï¼Œæ˜¾ç¤ºè¿æ¥éƒ¨åˆ†ï¼Œåœ¨è¿æ¥éƒ¨åˆ†æ˜¾ç¤ºé”™è¯¯
                    hideTwitterStatusSection();
                    showTwitterSection();
                    
                    // æ›´æ–°å›è°ƒçŠ¶æ€æç¤º
                    if (callbackDetails) {
                        callbackDetails.textContent = `ç»‘å®šå¤±è´¥ï¼š${error.message}`;
                    }
                    
                    const bindingFailedMsg = getI18nMessage('faucet.messages.twitterBindingFailed', 'X è´¦æˆ·ç»‘å®šå¤±è´¥');
                    showStatus('twitterOAuthStatus', 
                        `${bindingFailedMsg}: ${error.message}`, 
                        'error'
                    );
                }

                // æ¸…ç† URL å‚æ•°
                window.history.replaceState({}, document.title, window.location.pathname);
            } else {
                console.log('â„¹ï¸ æœªæ£€æµ‹åˆ° Twitter å›è°ƒå‚æ•°ï¼Œè·³è¿‡å¤„ç†');
            }
        }

        async function checkLocalAuth() {
            const savedToken = localStorage.getItem('faucetAuthToken');
            const savedUser = localStorage.getItem('faucetUser');

            if (savedToken && savedUser) {
                try {
                    authToken = savedToken;
                    const user = JSON.parse(savedUser);

                    if (isTokenExpired(savedToken)) {
                        console.log('æœ¬åœ°Tokenå·²è¿‡æœŸï¼Œæ¸…é™¤å­˜å‚¨');
                        localStorage.removeItem('faucetAuthToken');
                        localStorage.removeItem('faucetUser');
                        return false;
                    }

                    walletAddress = user.walletAddress;
                    console.log('ğŸ’¾ ä»æœ¬åœ°å­˜å‚¨æ¢å¤çŠ¶æ€:', {
                        Token: 'å­˜åœ¨',
                        é’±åŒ…åœ°å€: walletAddress,
                        ç”¨æˆ·ID: user.id
                    });

                    document.getElementById('connectTwitter').disabled = false;
                    document.getElementById('checkFaucetStatus').disabled = false;

                    console.log('ä»æœ¬åœ°å­˜å‚¨æ¢å¤äº†è®¤è¯çŠ¶æ€ï¼Œç­‰å¾…é’±åŒ…è¿æ¥éªŒè¯');

                    const walletConnectedMsg = getLanguageData(currentLang).faucet?.messages?.walletConnected || 'é’±åŒ…å·²è¿æ¥';
                    showStatus('walletStatus', `${walletConnectedMsg}: ${formatAddress(user.walletAddress)}`, 'success');

                    return true;
                } catch (error) {
                    console.error('è§£ææœ¬åœ°å­˜å‚¨çš„ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
                    localStorage.removeItem('faucetAuthToken');
                    localStorage.removeItem('faucetUser');
                    return false;
                }
            }
            return false;
        }

        function clearLocalAuth() {
            localStorage.removeItem('faucetAuthToken');
            localStorage.removeItem('faucetUser');
            authToken = null;
            
            // é‡ç½®ç›¸å…³æŒ‰é’®çŠ¶æ€
            document.getElementById('connectTwitter').disabled = true;
            document.getElementById('disconnectTwitter').disabled = true;
            document.getElementById('checkFaucetStatus').disabled = true;
            document.getElementById('claimTokens').disabled = true;
            
            // é‡ç½®å€’è®¡æ—¶
            if (countdownTimer) {
                clearInterval(countdownTimer);
                countdownTimer = null;
            }
            currentCooldownTime = 0;
            
            // é‡ç½®æŒ‰é’®æ˜¾ç¤º
            const buttonTextElement = document.getElementById('claimButtonText');
            const countdownElement = document.getElementById('claimCountdown');
            if (buttonTextElement) buttonTextElement.style.display = 'inline';
            if (countdownElement) countdownElement.style.display = 'none';
            
            console.log('å·²æ¸…é™¤æœ¬åœ°è®¤è¯çŠ¶æ€å’Œç›¸å…³UIçŠ¶æ€');
        }

        function isTokenExpired(token) {
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                const currentTime = Math.floor(Date.now() / 1000);

                if (payload.exp && payload.exp < currentTime) {
                    return true;
                }
                
                return false;
            } catch (error) {
                console.error('æ£€æŸ¥Tokenè¿‡æœŸæ—¶é—´å¤±è´¥:', error);
                return true;
            }
        }
        
        function autoClearAuth() {
            try {
                clearLocalAuth();
                
                showStatusI18n('walletStatus', 'faucet.messages.walletDisconnected', 'info');
                showStatus('twitterStatus', '', 'info');
                showStatus('faucetStatus', '', 'info');
                
                // é’±åŒ…æ–­å¼€æ—¶ï¼Œæ˜¾ç¤ºTwitter OAuth sectionï¼Œéšè—çŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½
                showTwitterSection();
                hideTwitterStatusSection();
                hideFaucetClaimSection();
                
                // æ¸…é™¤å…¶ä»–çŠ¶æ€
                currentNonce = null;
                currentMessage = null;
                faucetRecaptchaToken = null;
                
                console.log('é’±åŒ…æ–­å¼€è¿æ¥ï¼Œè®¤è¯çŠ¶æ€å·²è‡ªåŠ¨æ¸…é™¤');
                
            } catch (error) {
                console.error('è‡ªåŠ¨æ¸…é™¤è®¤è¯çŠ¶æ€å¤±è´¥:', error);
            }
        }

        async function autoStartAuthFlow() {
                         try {
                 
                 const response = await fetch(`${API_BASE}/nonce`, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json'
                     },
                     credentials: 'include',
                     body: JSON.stringify({ walletAddress })
                 });

                 const data = await response.json();

                 if (!data.success) {
                     throw new Error(data.message || data.error);
                 }

                 currentNonce = data.data.nonce;
                 currentMessage = data.data.message;
                
                 const signature = await window.ethereum.request({
                     method: 'personal_sign',
                     params: [currentMessage, walletAddress]
                 });

              
                const loginResponse = await fetch(`${API_BASE}/login`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    credentials: 'include',
                    body: JSON.stringify({
                        walletAddress,
                        signature,
                        message: currentMessage
                    })
                });

                const loginData = await loginResponse.json();

                if (!loginData.success) {
                    throw new Error(loginData.message || loginData.error);
                }

                authToken = loginData.data.token;
                const user = loginData.data.user;
                const isNewUser = loginData.data.isNewUser;

              
                localStorage.setItem('faucetAuthToken', authToken);
                localStorage.setItem('faucetUser', JSON.stringify(user));
                console.log('âœ… JWT Token å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨');

                                 showStatus('walletStatus', `é’±åŒ…å·²è¿æ¥: ${formatAddress(user.walletAddress)}`, 'success');


                 document.getElementById('connectTwitter').disabled = false;
                 document.getElementById('checkFaucetStatus').disabled = false;
                 checkClaimButtonState();
                
                
                setTimeout(async () => {
                    await autoCheckFaucetStatus();
                    await autoCheckTwitterStatus();
                }, 1000);

            } catch (error) {
                console.error('è‡ªåŠ¨è®¤è¯æµç¨‹å¤±è´¥:', error);
                
                                 if (error.message.includes('User rejected')) {
                     showStatusI18n('walletStatus', 'faucet.messages.userCancelledTransaction', 'warning');
                 } else {
                     showStatusI18n('walletStatus', 'faucet.messages.authFailed', 'error');
                 }
            }
        }

        
        async function autoCheckTwitterStatus() {
            try {
                const token = localStorage.getItem('faucetAuthToken') || authToken;
                if (!token) {
                    console.log('æ²¡æœ‰è®¤è¯tokenï¼Œè·³è¿‡TwitterçŠ¶æ€æ£€æŸ¥');
                    return;
                }

                console.log('ğŸ” è‡ªåŠ¨æ£€æŸ¥Twitterè¿æ¥çŠ¶æ€...');
                
                const response = await fetch(`${API_BASE}/twitter/status`, {
                    credentials: 'include',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    // å¦‚æœæ˜¯401é”™è¯¯ï¼Œå°è¯•è‡ªåŠ¨é‡æ–°ç™»å½•
                    if (response.status === 401) {
                        console.log('ğŸ”‘ æ£€æµ‹åˆ°401é”™è¯¯ï¼Œå°è¯•è‡ªåŠ¨é‡æ–°ç™»å½•...');
                        
                        try {
                            // è·å–æ–°çš„nonce
                            const nonceResponse = await fetch(`${API_BASE}/nonce`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'include',
                                body: JSON.stringify({ walletAddress })
                            });

                            const nonceData = await nonceResponse.json();
                            
                            if (!nonceData.success) {
                                throw new Error(`è·å–nonceå¤±è´¥: ${nonceData.message || nonceData.error}`);
                            }

                            const nonce = nonceData.data.nonce;
                            const message = nonceData.data.message;

                            // è¯·æ±‚ç”¨æˆ·ç­¾å
                            const signature = await window.ethereum.request({
                                method: 'personal_sign',
                                params: [message, walletAddress]
                            });

                            // ä½¿ç”¨ç­¾åç™»å½•
                            const loginResponse = await fetch(`${API_BASE}/login`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'include',
                                body: JSON.stringify({
                                    walletAddress,
                                    signature,
                                    message
                                })
                            });

                            const loginData = await loginResponse.json();
                            
                            if (!loginData.success) {
                                throw new Error(`è‡ªåŠ¨ç™»å½•å¤±è´¥: ${loginData.message || loginData.error}`);
                            }

                            console.log('âœ… è‡ªåŠ¨é‡æ–°ç™»å½•æˆåŠŸï¼Œæ›´æ–°tokenå¹¶é‡æ–°æ£€æŸ¥TwitterçŠ¶æ€');
                            
                            // æ›´æ–°token
                            authToken = loginData.data.token;
                            localStorage.setItem('faucetAuthToken', authToken);
                            localStorage.setItem('faucetUser', JSON.stringify(loginData.data.user));
                            
                            // é‡æ–°æ£€æŸ¥TwitterçŠ¶æ€
                            await autoCheckTwitterStatus();
                            return;
                            
                        } catch (autoLoginError) {
                            console.error('è‡ªåŠ¨é‡æ–°ç™»å½•å¤±è´¥:', autoLoginError);
                            // å¦‚æœè‡ªåŠ¨ç™»å½•å¤±è´¥ï¼Œå›é€€åˆ°æ˜¾ç¤ºè¿æ¥éƒ¨åˆ†
                        }
                    }
                    
                    console.log('TwitterçŠ¶æ€æ£€æŸ¥å¤±è´¥ï¼Œæ˜¾ç¤ºTwitterè¿æ¥éƒ¨åˆ†ï¼Œéšè—çŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½');
                    showTwitterSection();
                    hideTwitterStatusSection();
                    hideFaucetClaimSection();
                    return;
                }

                const data = await response.json();

                if (data.success) {
                    const { connected, twitter } = data.data;
                    
                    if (connected && twitter) {
                        console.log('âœ… Twitterå·²è¿æ¥ï¼Œéšè—Twitterè¿æ¥éƒ¨åˆ†ï¼Œæ˜¾ç¤ºçŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½');
                        hideTwitterSection();
                        showTwitterStatusSection();
                        showFaucetClaimSection();
                        
                        // å¯é€‰ï¼šæ˜¾ç¤ºTwitterè¿æ¥çŠ¶æ€ä¿¡æ¯
                        const twitterConnectedMsg = getI18nMessage('faucet.messages.twitterConnected', 'âœ… Twitter å·²è¿æ¥');
                        const displayNameMsg = getI18nMessage('faucet.messages.displayName', 'æ˜¾ç¤ºå');
                        const verifiedMsg = getI18nMessage('faucet.messages.verified', 'éªŒè¯çŠ¶æ€');
                        const connectedAtMsg = getI18nMessage('faucet.messages.connectedAt', 'è¿æ¥æ—¶é—´');
                        const verifiedStatusMsg = twitter.verified ? 
                            getI18nMessage('faucet.messages.verified_', 'å·²éªŒè¯') : 
                            getI18nMessage('faucet.messages.unverified', 'æœªéªŒè¯');
                        
                        showStatus('twitterStatus', 
                            `${twitterConnectedMsg}: @${twitter.username}<br>` +
                            `<div class="text-sm text-gray-600 mt-2">` +
                            `${displayNameMsg}: ${twitter.name} | ` +
                            `${verifiedMsg}: ${verifiedStatusMsg} | ` +
                            `${connectedAtMsg}: ${new Date(twitter.connectedAt).toLocaleString()}` +
                            `</div>`,
                            'success'
                        );
                    } else {
                        console.log('Twitteræœªè¿æ¥ï¼Œæ˜¾ç¤ºTwitterè¿æ¥éƒ¨åˆ†ï¼Œéšè—çŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½');
                        showTwitterSection();
                        hideTwitterStatusSection();
                        hideFaucetClaimSection();
                    }
                } else {
                    console.log('TwitterçŠ¶æ€æ£€æŸ¥è¿”å›å¤±è´¥ï¼Œæ˜¾ç¤ºTwitterè¿æ¥éƒ¨åˆ†ï¼Œéšè—çŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½');
                    showTwitterSection();
                    hideTwitterStatusSection();
                    hideFaucetClaimSection();
                }

            } catch (error) {
                console.error('è‡ªåŠ¨æ£€æŸ¥TwitterçŠ¶æ€å¤±è´¥:', error);
                showTwitterSection();
                hideTwitterStatusSection();
                hideFaucetClaimSection();
            }
        }

        function hideTwitterSection() {
            const twitterSection = document.getElementById('twitterOAuthSection');
            if (twitterSection) {
                twitterSection.style.display = 'none';
                console.log('Twitter OAuth é›†æˆéƒ¨åˆ†å·²éšè—');
            }
        }

        function showTwitterSection() {
            const twitterSection = document.getElementById('twitterOAuthSection');
            if (twitterSection) {
                twitterSection.style.display = 'block';
                console.log('Twitter OAuth é›†æˆéƒ¨åˆ†å·²æ˜¾ç¤º');
            }
        }

        function showTwitterStatusSection() {
            const twitterStatusSection = document.getElementById('twitterStatusSection');
            console.log('ğŸ”§ showTwitterStatusSection è°ƒç”¨, å…ƒç´ :', twitterStatusSection);
            if (twitterStatusSection) {
                twitterStatusSection.style.display = 'block';
                console.log('âœ… Twitter çŠ¶æ€éƒ¨åˆ†å·²æ˜¾ç¤º');
                
                // æ£€æŸ¥ twitterStatus å­å…ƒç´ 
                const twitterStatus = document.getElementById('twitterStatus');
                console.log('ğŸ”§ twitterStatus å­å…ƒç´ :', twitterStatus);
            } else {
                console.error('âŒ æ‰¾ä¸åˆ° twitterStatusSection å…ƒç´ ');
            }
        }

        function hideTwitterStatusSection() {
            const twitterStatusSection = document.getElementById('twitterStatusSection');
            if (twitterStatusSection) {
                twitterStatusSection.style.display = 'none';
                console.log('Twitter çŠ¶æ€éƒ¨åˆ†å·²éšè—');
            }
        }

        function hideFaucetClaimSection() {
            const faucetSection = document.getElementById('faucetClaimSection');
            if (faucetSection) {
                faucetSection.style.display = 'none';
                console.log('é¢†å– PHRS ä»£å¸éƒ¨åˆ†å·²éšè—');
            }
        }

        function showFaucetClaimSection() {
            const faucetSection = document.getElementById('faucetClaimSection');
            if (faucetSection) {
                faucetSection.style.display = 'block';
                console.log('é¢†å– PHRS ä»£å¸éƒ¨åˆ†å·²æ˜¾ç¤º');
            }
        }
        
        async function autoCheckFaucetStatus() {
            try {
                showStatus('faucetStatus', 'è‡ªåŠ¨æ£€æŸ¥æ°´é¾™å¤´çŠ¶æ€...', 'info');

                const token = localStorage.getItem('faucetAuthToken') || authToken;
                if (!token) {
                    throw new Error('è¯·å…ˆç™»å½•');
                }

                const response = await fetch(`${API_BASE}/claim/status`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    },
                    credentials: 'include'
                });

                const data = await response.json();

                if (!data.success) {
                    throw new Error(data.message || data.error);
                }

                const { canClaim, user, ip, twitter, rateLimit } = data.data;

                let statusHtml = `<div class="bg-gray-50 p-3 rounded">`;
                statusHtml += `<strong>é¢†å–çŠ¶æ€:</strong> ${canClaim ? 'å¯ä»¥é¢†å–' : 'æš‚æ—¶æ— æ³•é¢†å–'}<br><br>`;

                statusHtml += `<strong>ç”¨æˆ·çŠ¶æ€:</strong><br>`;
                statusHtml += `åœ°å€: ${user.address.slice(0,6)}...${user.address.slice(-4)}<br>`;
                statusHtml += `å¯é¢†å–: ${user.canClaim ? 'æ˜¯' : 'å¦'}<br>`;
                if (user.remainingTime) {
                    statusHtml += `å†·å´å‰©ä½™: ${Math.floor(user.remainingTime / 3600)}å°æ—¶${Math.floor((user.remainingTime % 3600) / 60)}åˆ†é’Ÿ<br>`;
                }

                statusHtml += `<br><strong>IP çŠ¶æ€:</strong><br>`;
                statusHtml += `åœ°å€: ${ip.address}<br>`;
                statusHtml += `å¯é¢†å–: ${ip.canClaim ? 'æ˜¯' : 'å¦'}<br>`;
                if (ip.remainingTime) {
                    statusHtml += `å†·å´å‰©ä½™: ${Math.floor(ip.remainingTime / 3600)}å°æ—¶${Math.floor((ip.remainingTime % 3600) / 60)}åˆ†é’Ÿ<br>`;
                }

                statusHtml += `<br><strong>Twitter çŠ¶æ€:</strong><br>`;
                statusHtml += `ç»‘å®šçŠ¶æ€: ${twitter.isBound ? 'å·²ç»‘å®š' : 'æœªç»‘å®š'}<br>`;
                if (twitter.username) {
                    statusHtml += `ç”¨æˆ·å: @${twitter.username}<br>`;
                }
                if (twitter.isBound) {
                    statusHtml += `å¯é¢†å–: ${twitter.canClaim ? 'æ˜¯' : 'å¦'}<br>`;
                    if (twitter.remainingTime) {
                        statusHtml += `å†·å´å‰©ä½™: ${Math.floor(twitter.remainingTime / 3600)}å°æ—¶${Math.floor((twitter.remainingTime % 3600) / 60)}åˆ†é’Ÿ<br>`;
                    }
                }

                statusHtml += `<br><strong>é€Ÿç‡é™åˆ¶:</strong><br>`;
                statusHtml += `å…è®¸è¯·æ±‚: ${rateLimit.allowed ? 'æ˜¯' : 'å¦'}<br>`;
                statusHtml += `å‰©ä½™æ¬¡æ•°: ${rateLimit.remaining}<br>`;
                statusHtml += `</div>`;

                showStatus('faucetStatus', statusHtml, canClaim ? 'success' : 'error');

              
                let maxCooldownTime = 0;
                if (user.remainingTime && user.remainingTime > 0) {
                    maxCooldownTime = Math.max(maxCooldownTime, user.remainingTime);
                }
                if (ip.remainingTime && ip.remainingTime > 0) {
                    maxCooldownTime = Math.max(maxCooldownTime, ip.remainingTime);
                }
                if (twitter.remainingTime && twitter.remainingTime > 0) {
                    maxCooldownTime = Math.max(maxCooldownTime, twitter.remainingTime);
                }

               
                startCountdown(maxCooldownTime);

            } catch (error) {
                const autoCheckFailedMsg = getLanguageData(currentLang).faucet?.messages?.autoFaucetCheckFailed || 'è‡ªåŠ¨æ£€æŸ¥æ°´é¾™å¤´çŠ¶æ€å¤±è´¥';
                showStatus('faucetStatus', `${autoCheckFailedMsg}: ${error.message}`, 'error');
            }
        }

     
        async function onWalletConnected(address) {
            console.log('ğŸ”Œ é’±åŒ…è¿æ¥äº‹ä»¶:', {
                è¿æ¥åœ°å€: address,
                å½“å‰è®¤è¯Token: authToken ? 'å­˜åœ¨' : 'ä¸å­˜åœ¨',
                å½“å‰é’±åŒ…åœ°å€: walletAddress || 'æœªè®¾ç½®',
                åœ°å€åŒ¹é…: walletAddress === address,
                æ˜¯å¦ä¸ºè´¦æˆ·åˆ‡æ¢: walletAddress && walletAddress !== address
            });
            
            // æ£€æµ‹è´¦æˆ·åˆ‡æ¢
            const isAccountSwitch = walletAddress && walletAddress.toLowerCase() !== address.toLowerCase();
            
            if (isAccountSwitch) {
                console.log('ğŸ”„ æ£€æµ‹åˆ°è´¦æˆ·åˆ‡æ¢ï¼Œä»', walletAddress, 'åˆ‡æ¢åˆ°', address);
                showStatus('walletStatus', 
                    `ğŸ”„ æ£€æµ‹åˆ°è´¦æˆ·åˆ‡æ¢<br><br>` +
                    `ä»: ${formatAddress(walletAddress)}<br>` +
                    `åˆ°: ${formatAddress(address)}<br><br>` +
                    `æ­£åœ¨æ¸…é™¤æ—§è´¦æˆ·è®¤è¯çŠ¶æ€å¹¶é‡æ–°è®¤è¯...`, 
                    'info'
                );
                
                // æ¸…é™¤æ—§è´¦æˆ·çš„è®¤è¯çŠ¶æ€
                clearLocalAuth();
                
                // é‡ç½®Twitter OAuth sectionæ˜¾ç¤ºçŠ¶æ€ï¼Œéšè—çŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½
                showTwitterSection();
                hideTwitterStatusSection();
                hideFaucetClaimSection();
                
                // æ¸…ç†çŠ¶æ€æ˜¾ç¤º
                showStatusI18n('twitterStatus', 'faucet.messages.waitingForAuth', 'info');
                showStatusI18n('faucetStatus', 'faucet.messages.waitingForFaucetAuth', 'info');
                
                // æ›´æ–°é’±åŒ…åœ°å€å¹¶å¼€å§‹æ–°çš„è®¤è¯æµç¨‹
                walletAddress = address;
                const newAccountMsg = getLanguageData(currentLang).faucet?.messages?.newAccountAuthenticating || 'ğŸ”„ æ–°è´¦æˆ·è®¤è¯ä¸­';
                showStatus('walletStatus', `${newAccountMsg}: ${formatAddress(address)}`, 'info');
                checkClaimButtonState();
                autoStartAuthFlow();
                return;
            }

            if (authToken && walletAddress === address) {
                console.log('ğŸ” éªŒè¯ç°æœ‰Tokenæ˜¯å¦ä»ç„¶æœ‰æ•ˆ...');
                
                try {
                    console.log('ğŸ” ä½¿ç”¨ /me API éªŒè¯Tokenæœ‰æ•ˆæ€§...');
                    const response = await fetch(`${API_BASE}/me`, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${authToken}`
                        },
                        credentials: 'include'
                    });

                    const data = await response.json();

                    if (data.success && data.data && data.data.user) {
                        const user = data.data.user;
                        console.log('âœ… TokenéªŒè¯æˆåŠŸï¼Œç”¨æˆ·ä¿¡æ¯:', user);
                        
                        if (user.walletAddress.toLowerCase() === address.toLowerCase()) {
                            const walletConnectedMsg = getLanguageData(currentLang).faucet?.messages?.walletConnected || 'é’±åŒ…å·²è¿æ¥';
                            showStatus('walletStatus', `${walletConnectedMsg}: ${formatAddress(address)}`, 'success');
                            checkClaimButtonState();
                            
                            setTimeout(async () => {
                                try {
                                    await autoCheckFaucetStatus();
                                    await autoCheckTwitterStatus();
                                } catch (error) {
                                    console.log('è‡ªåŠ¨æ£€æŸ¥çŠ¶æ€å¤±è´¥:', error.message);
                                }
                            }, 1000);
                            
                            return;
                        } else {
                            console.log('âŒ é’±åŒ…åœ°å€ä¸åŒ¹é…ï¼Œæ¸…é™¤è®¤è¯çŠ¶æ€');
                            console.log('å­˜å‚¨çš„é’±åŒ…åœ°å€:', user.walletAddress);
                            console.log('è¿æ¥çš„é’±åŒ…åœ°å€:', address);
                            clearLocalAuth();
                        }
                    } else {
                        console.log('âŒ TokenéªŒè¯å¤±è´¥:', data.message || data.error);
                        clearLocalAuth();
                    }
                } catch (verifyError) {
                    console.log('TokenéªŒè¯è¯·æ±‚å¤±è´¥:', verifyError.message);
                    clearLocalAuth();
                }
            }
            
            walletAddress = address;
            console.log('ğŸ”„ å¼€å§‹æ–°çš„è®¤è¯æµç¨‹ï¼Œå› ä¸º:', authToken ? 'Tokenæ— æ•ˆæˆ–é’±åŒ…åœ°å€ä¸åŒ¹é…' : 'Tokenä¸å­˜åœ¨');
            
            const walletConnectedMsg = getLanguageData(currentLang).faucet?.messages?.walletConnected || 'é’±åŒ…å·²è¿æ¥';
            showStatus('walletStatus', `${walletConnectedMsg}: ${formatAddress(address)}`, 'success');
            checkClaimButtonState();
            
            autoStartAuthFlow();
        }

        function onWalletDisconnected() {
            walletAddress = null;
                            showStatusI18n('walletStatus', 'faucet.messages.walletDisconnectedAppKit', 'info');
            checkClaimButtonState();
            
            autoClearAuth();
        }

        // æ£€æŸ¥ URL ä¸­æ˜¯å¦æœ‰ Twitter å›è°ƒå‚æ•°
        function checkTwitterCallbackInURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const state = urlParams.get('state');
            const code = urlParams.get('code');
            
            if (state && code) {
                console.log('ğŸ” æ£€æµ‹åˆ° Twitter å›è°ƒå‚æ•°:', { state, code });
                
                const callbackStatus = document.getElementById('twitterCallbackStatus');
                const callbackDetails = document.getElementById('twitterCallbackDetails');
                if (callbackStatus && callbackDetails) {
                    callbackStatus.style.display = 'block';
                    callbackDetails.textContent = 'æ£€æµ‹åˆ° Twitter æˆæƒå›è°ƒï¼Œæ­£åœ¨å¤„ç†...';
                }
                
                // æ˜¾ç¤ºæˆåŠŸæç¤º
                const authSuccessMsg = getI18nMessage('faucet.messages.twitterAuthSuccess', 'âœ… Twitter æˆæƒæˆåŠŸï¼');
                const processingBindingMsg = getI18nMessage('faucet.messages.processingBinding', 'æ£€æµ‹åˆ°æˆæƒå›è°ƒå‚æ•°ï¼Œæ­£åœ¨å¤„ç†ç»‘å®š...');
                const callbackInfoMsg = getI18nMessage('faucet.messages.callbackInfo', 'å›è°ƒä¿¡æ¯:');
                const bindingNoticeMsg = getI18nMessage('faucet.messages.bindingNotice', 'å¦‚æœç»‘å®šå¤±è´¥ï¼Œè¯·ç¡®ä¿å·²è¿æ¥é’±åŒ…å¹¶å®Œæˆç­¾åè®¤è¯ã€‚');
                
                showStatus('twitterStatus', 
                    `<div class="bg-green-50 p-4 rounded border border-green-200">` +
                    `<strong>${authSuccessMsg}</strong><br>` +
                    `${processingBindingMsg}<br><br>` +
                    `<strong>${callbackInfoMsg}</strong><br>` +
                    `State: ${state.substring(0, 20)}...<br>` +
                    `Code: ${code.substring(0, 20)}...<br><br>` +
                    `${bindingNoticeMsg}` +
                    `</div>`, 
                    'success'
                );
                
                return true; // è¡¨ç¤ºæ£€æµ‹åˆ°å›è°ƒ
            }
            
            return false; // è¡¨ç¤ºæ²¡æœ‰æ£€æµ‹åˆ°å›è°ƒ
        }

        // æ£€æŸ¥æ˜¯å¦éœ€è¦é‡å®šå‘åˆ° faucet.htmlï¼ˆå¦‚æœåœ¨å…¶ä»–é¡µé¢ä½†æœ‰ Twitter å›è°ƒå‚æ•°ï¼‰
        function checkAndRedirectToFaucet() {
            const urlParams = new URLSearchParams(window.location.search);
            const state = urlParams.get('state');
            const code = urlParams.get('code');
            
            // å¦‚æœå½“å‰ä¸åœ¨ faucet.html é¡µé¢ï¼Œä½†æœ‰ Twitter å›è°ƒå‚æ•°
            if ((state && code) && !window.location.pathname.includes('faucet.html')) {
                console.log('ğŸ”„ æ£€æµ‹åˆ° Twitter å›è°ƒå‚æ•°ï¼Œä½†ä¸åœ¨ faucet.html é¡µé¢ï¼Œè‡ªåŠ¨é‡å®šå‘...');
                
                // ä¿ç•™æ‰€æœ‰ URL å‚æ•°ï¼Œé‡å®šå‘åˆ° faucet.html
                const newUrl = `${window.location.origin}/faucet.html${window.location.search}`;
                console.log('é‡å®šå‘åˆ°:', newUrl);
                window.location.href = newUrl;
                return true; // è¡¨ç¤ºæ­£åœ¨é‡å®šå‘
            }
            
            return false; // è¡¨ç¤ºä¸éœ€è¦é‡å®šå‘
        }

        window.addEventListener('load', async () => {
            // é¦–å…ˆæ£€æŸ¥æ˜¯å¦éœ€è¦é‡å®šå‘åˆ° faucet.html
            if (checkAndRedirectToFaucet()) {
                return; // å¦‚æœæ­£åœ¨é‡å®šå‘ï¼Œåœæ­¢åç»­å¤„ç†
            }
            
            initLanguage();
            
            try {
                await checkEthersLoaded();
                console.log('ethers.js åŠ è½½æˆåŠŸ');
            } catch (error) {
                console.error('ethers.js åŠ è½½å¤±è´¥:', error.message);
                showStatusI18n('faucetStatus', 'faucet.messages.dependencyLoadFailed', 'error');
            }

            const authRestored = await checkLocalAuth();
            
            if (authRestored) {
                showStatus('walletStatus', 'é’±åŒ…å·²è¿æ¥', 'success');
                
                // å¦‚æœè®¤è¯çŠ¶æ€å·²æ¢å¤ï¼Œç«‹å³æ£€æŸ¥TwitterçŠ¶æ€
                setTimeout(async () => {
                    await autoCheckTwitterStatus();
                }, 500);
            } else {
                showStatusI18n('walletStatus', 'faucet.messages.waitingWalletConnection', 'info');
                
                // å¦‚æœæ²¡æœ‰è®¤è¯çŠ¶æ€ï¼Œæ˜¾ç¤ºTwitterè¿æ¥éƒ¨åˆ†ï¼Œéšè—çŠ¶æ€éƒ¨åˆ†å’Œæ°´é¾™å¤´åŠŸèƒ½
                showTwitterSection();
                hideTwitterStatusSection();
                hideFaucetClaimSection();
            }

            // æ£€æŸ¥ Twitter å›è°ƒå‚æ•°
            const hasCallback = checkTwitterCallbackInURL();
            
            // å¤„ç† Twitter å›è°ƒ
            if (hasCallback) {
                console.log('ğŸ”„ æ£€æµ‹åˆ° Twitter å›è°ƒï¼Œå¼€å§‹å¤„ç†ç»‘å®š...');
                handleTwitterCallback();
            } else {
                console.log('â„¹ï¸ æœªæ£€æµ‹åˆ° Twitter å›è°ƒï¼Œè·³è¿‡å¤„ç†');
            }

        });

    
    </script>

</body>
</html>
